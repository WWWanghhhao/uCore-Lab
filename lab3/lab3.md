### 练习

对实验报告的要求：
 - 基于markdown格式来完成，以文本方式为主
 - 填写各个基本练习中要求完成的报告内容
 - 完成实验后，请分析ucore_lab中提供的参考答案，并请在实验报告中说明你的实现与参考答案的区别
 - 列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解（也可能出现实验中的知识点没有对应的原理知识点）
 - 列出你认为OS原理中很重要，但在实验中没有对应上的知识点
 
#### 练习0：填写已有实验
本实验依赖实验1/2。请把你做的实验1/2的代码填入本实验中代码中有“LAB1”,“LAB2”的注释相应部分。

# lab3实验报告
## 练习1：
### 换入：
当程序访问"不对应物理内存页帧的虚拟内存地址"时CPU抛出Page Fault异常。调用exception_handler用于处理异常，在这个函数内部，根据当前异常的类型调用pgfault_handler处理缺页异常。这个函数又会调用do_pgfault(check_mm_struct, tf->cause, tf->badvaddr);进行主要的处理。

do_pgfault中，会调用find_vma 函数查找虚拟内存区域，确保故障地址在有效的 vma 范围内。调用 get_pte 查找页表项。如果页表项为空（页不在内存中），则分配一页内存并更新页表。如果页表项存在，但该页面在交换区中，则调用 swap_in 从磁盘中读取数据到内存。如果页面从交换区加载到内存，则通过 page_insert 将物理页面插入到页表中，并标记该页面可以交换。

接下来重点看看swap_in这个函数。该函数的目的是将一个页面从磁盘的交换区加载到内存。swap_in中会调用swapfs_read((*ptep), result),根据交换区条目的地址，读取数据到新分配的页面 result。最后记录读取信息并返回。

### 换出：
在alloc_pages函数中，swap_out 被调用的条件是当页分配失败时，而且当前请求的页数 n 大于 1 且交换区初始化 (swap_init_ok) 处于有效状态。这段代码的目的是在无法分配到所需数量的页面时，通过调用页面置换（swap_out）来尝试获得页面。

swap_out用于将内存中的页面交换到磁盘的交换区。运行过程中，会调用swap_out_victim调用交换算法来选择一个页面（page）作为交换出的牺牲品。
接着调用get_pte根据虚拟地址 v 获取页表项 ptep，用assert((*ptep & PTE_V) != 0);检查页表项是否有效。随后调用swapfs_write将页面数据写入交换区，交换区的地址通过页面的虚拟地址计算得出。如果写入失败，则调用 map_swappable 将该页面标记为不可交换，并继续下一个页面。如果写入交换区成功，更新页表项，将其设置为交换区的地址。最后free_page(page)释放该物理页面并tlb_invalidate(mm->pgdir, v);刷新 TLB。

目前swap_out_victim对于的替换算法是fifo。fifo的核心逻辑在函数_fifo_swap_out_victim中实现。该函数选择一个“牺牲”页面（即队列中最早加载的页面），并将其从fifo队列中移除，以便进行页面替换。

## 练习2：

### (1) get_pte() 函数中两段相似代码的原因分析

在get_pte()函数中，代码主要用于分层级地获取或创建页表项。其核心是通过分级遍历页目录（page directory）和页表（page table），逐层定位到某个虚拟地址（la）对应的物理页。我们看到函数中的两段代码确实相似，这源于 RISC-V 的多级页表机制（如 SV32、SV39、SV48），它们虽然页表层数不同，但操作逻辑一致。

#### RISC-V 分页模式的结构特性
- SV32: 适用于 32 位虚拟地址。
使用 2 级页表，页目录（第一级页表）有 10 位索引，页表（第二级页表）也有 10 位索引。
- SV39: 
适用于 39 位虚拟地址。
使用 3 级页表，每一级页表分别使用 9 位索引。
- SV48: 
适用于 48 位虚拟地址。
使用 4 级页表，每一级页表分别使用 9 位索引。

由于 RISC-V 分页机制的逐级分页结构，代码需要逐层依次检查、创建各级页表项。这个操作模式在不同层之间几乎完全一致，因此代码相似。

### (2) get_pte()函数合并查找和分配的分析

get_pte的主要运行逻辑是这样：首先根据虚拟地址的高位找到第一级页目录项（pdep1）。如果第一级页表不存在，且 create 为真，则分配新页面。随后相似地根据虚拟地址的中间位找到第二级页目录项（pdep0）。如果第二级页表不存在，且 create 为真，则分配新页面。最后根据虚拟地址的低位找到最终页表项（pte_t）。返回虚拟地址对应的页表项指针。

get_pte函数中，包含页表项的查找和页表项的分配。在查找一个页表项时，如果该页表项不存在，如何调用者允许create则会创建一个新的页表。我认为这种写法是可以的，合并可以减少函数的数量，避免在调用时需要分别调用查找函数和分配函数。调用者只需要调用一次get_pte，即可在查找页表项的同时自动处理不存在的页表项的分配。这对于调用者来说非常直观，避免了多次的函数调用和条件判断。并且对于常见的访问模式（即查找页表项并在必要时创建它们），这种设计减少了代码重复。在这种实现中，创建的逻辑紧跟在查找逻辑之后，能够清晰地捕获“页表不存在时如何处理”的逻辑。

## 练习3：

### (1)设计思路：
检查swap_init_ok标志，确保交换系统已初始化。如果交换系统已初始化，调用swap_in将交换区中的页面加载到内存中，并使用page_insert更新页表，将加载的页面与虚拟地址addr进行映射。接着，调用swap_map_swappable标记该页面可以被交换出去。
最后，page->pra_vaddr = addr;表示该页被映射到虚拟地址addr。

### (2)潜在用处：
在页替换算法中，如果页表项的 PTE_D 被设置为 1（表示该页被修改过），操作系统在将页换出内存时需要将该页的内容写回磁盘或交换空间。通过使用 PTE_D 标志，操作系统可以确保只有被修改过的页才会进行写回，从而减少不必要的写操作。

在实现页替换算法（如 LRU 或 FIFO）时，操作系统可以通过 PTE_A 字段来判断一个页面是否已经被访问。

页目录项和页表项都具有有效性位（PTE_V）。操作系统可以根据这些有效性位判断页表项是否有效，进而判断是否需要加载新的页表或者页面。 

如果某些页面是全局的，它们可能不适用于某些页替换算法，因为它们需要在所有进程中共享。

在多级页表中，页目录项（PDE）提供了对整个页表层级结构的访问。每个PDE都指向一个页表，当访问一个虚拟地址时，操作系统首先需要检查该页目录项是否有效。如果PDE无效，操作系统就需要通过磁盘加载相应的页表项。

### (3)硬件要做的事情：

触发异常：当访问一个无效或未加载的虚拟地址时，硬件会触发页访问异常。

保存上下文：CPU 保存当前的寄存器状态。

传递异常信息：通过 cause， badvaddr等寄存器传递异常的类型。

堆栈切换：CPU 切换到内核模式和内核栈。

中断处理程序：控制权转移到操作系统的缺页异常处理程序。

### (4)page与pde，pte的关系：
页表项（PTE）指向一个物理页面（物理页面号，PPN）。该物理页面地址会映射到物理内存中的某一块区域，而 struct Page 中的元素描述了物理内存中的一个页面的详细信息。因此，struct Page 与页表项（PTE）之间存在一种对应关系，每个物理页面都会有一个对应的 Page 结构体实例。

页目录项（PDE）与 Page 结构体之间的关系不如 PTE 那样直接。PDE 本身并不直接指向一个物理页面，而是指向一个页表。PDE 主要间接地影响了 PTE 的映射，因此与 struct Page 没有直接的对应关系。

总的来说，页表项（PTE）中的物理页地址（PPN）与 struct Page 数组中的页面直接对应。每个物理页面都对应一个 struct Page 实例。页目录项（PDE）间接影响页表的映射，但没有直接指向 Page 结构体的对应关系。页目录项主要作用于高层次的虚拟内存管理，而 struct Page 主要描述物理页面的状态。

---


#### 练习4：补充完成Clock页替换算法（需要编程）
通过之前的练习，相信大家对FIFO的页面替换算法有了更深入的了解，现在请在我们给出的框架上，填写代码，实现 Clock页替换算法（mm/swap_clock.c）。
请在实验报告中简要说明你的设计实现过程。请回答如下问题：
 - 比较Clock页替换算法和FIFO算法的不同。

 对于⻚⾯链表pra_list_head来说，clock⻚替换算法在每次加⼊新⻚时添加到链表的末尾，⽽执⾏换出⻚⾯时从全局变量当前指针
curr_ptr开始查找最早未被访问的⻚⾯。则_clock_swap_out_victim函数中的循环意图即为从当前指针开始查找，如果该⻚⾯已
被访问则将visited状态设置为0起到重置作⽤，如果该⻚⾯未被访问，则调⽤list_del函数将该⻚⾯从⻚⾯链表中删除，并将该⻚
⾯指针赋值给参数ptr_page（*ptr_page=ptr）作为换出⻚⾯。这样即使链表中所有⻚之前都被访问过，也会按照该逻辑遍历⼀圈
后删除curr_ptr指向的⻚⾯。
与之相反的是FIFO算法，其每次添加新⻚时添加到链表的头部，每次换出⻚⾯时调⽤list_prev找链表头的前⼀个节点（因为是双向
链表，直接找到链表尾）来进⾏换出，如果该⻚⾯不是链表头（是链表头意味着只有⼀个元素，按照换出逻辑来说不存在该情况）
则将该⻚⾯赋值给参数ptr_page作为换出⻚⾯；
注意到curr_ptr的本质作⽤也是指向最⽼的⻚⾯，不过其会随着链表的插⼊删除变化，⽽不是每次都从链表头遍历。当然更关键的
是clock考虑了⻚⾯的访问情况，⽽不是像FIFO⼀样粗暴的驱逐最早进⼊的⻚⾯。

#### 练习5：阅读代码和实现手册，理解页表映射方式相关知识（思考题）
如果我们采用”一个大页“ 的页表映射方式，相比分级页表，有什么好处、优势，有什么坏处、风险？

好处：当操作系统启动时，boot_page_table_sv39 就采⽤了⼀个⼤⻚的映射⽅式，这⼀⽅式能够简便地将操作
系统从物理地址的模式切换到虚拟地址模式⽽不⽤进⾏多级映射关系的处理。同时也减少了⻚表项的数量，节省了内存空间。由
于⻚表项数量减少，"⼀个⼤⻚"的⻚表映射⽅式可以提⾼访问效率，在分级⻚表中，访问⼀个虚拟⻚需要多次查找⻚表项，⽽使
⽤"⼀个⼤⻚"的⻚表映射⽅式只需要⼀次查找即可。还可以减少TLBmiss，当⼀个⼤⻚被加载到TLB中，可以覆盖更多的虚拟地
址范围，减少了TLB缺失的次数，提⾼了内存访问的效率。

坏处：然⽽，如果在多个进程的情况下，使⽤⼀个⼤⻚进⾏映射意味着在发⽣缺⻚异常和需要⻚⾯置换时需要把整个⼤⻚的内容
（在Sv39下即为1GiB）全部交换到硬盘上，在换回时也需要将所有的内容⼀起写回。在物理内存⼤⼩不够、进程数量较多⽽必
须要进⾏置换时，这会造成程序运⾏速度的降低。还可能会导致内存碎⽚的问题，内存利⽤率较低。最后，安全隐患也值得考
虑，⼀个⼤⻚泄露更易导致更多信息泄露。

综上，采⽤"⼀个⼤⻚"的⻚表映射⽅式可以减少⻚表项数量、提⾼访问效率和减少TLB缺失。然⽽，它也⾯临内存碎⽚、⼤⻚分配开
销和内存利⽤效率等问题

#### 扩展练习 Challenge：实现不考虑实现开销和效率的LRU页替换算法（需要编程）
challenge部分不是必做部分，不过在正确最后会酌情加分。需写出有详细的设计、分析和测试的实验报告。完成出色的可获得适当加分。
