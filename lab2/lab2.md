# lab2
## 基础
1. 使用页表机制：RISCV:sv39 页大小：4k
2. 物理地址 (Physical Address) 有 56 位，虚拟地址 (Virtual Address) 有 39 位，虚拟地址`高位补齐`， 能够表示的范围：2^(位数-12)
3. 最后 12 位表示的是页内偏移。


### 页表项
1. 描述一个虚拟页号如何映射到物理页号
2. 有上述知，56-12=44，页表项需要44位来保存物理页号。
3. 页表项的结构：63-54位为保留位，53-10位为物理页号，9-0位为映射的状态信息位。

5. 状态位的介绍：
   1. RSW(2bit) 域留给操作系统使用，它会被硬件忽略。两位留给 S Mode 的应用程序，我们可以用来进行拓展。
   2. D：dirty，该页是否被写过
   3. A：accessed，该页是否被访问过
   4. G：global，该页是否是全局页
   5. U：user，该页是否属于用户态，若属于用户态，则为安全考虑，S Mode 的应用程序不能访问该页
   6. V：valid，该页是否有效，若无效，则说明该页还没有被分配物理内存，其它位无意义
   7. 剩下根据状态位三位(read、write、execute)RWX的取值不同，分别代表不同含义：


### 多级页表
sv39采用三级页表
1. 大小分别为：有 4KiB=4096 字节的页，大小为 2MiB=2^21 字节的大页，和大小为 1 GiB 的大大页。
2. 由于虚拟地址为39位，去除12位页内偏移，剩下27位，每一级页表的偏移9位，因此共计512G的虚拟内存地址空间
3. 每一级页表的大小：512bit*8=4KiB；包括512个页表项，每个页表项8字节
   
### 页表基址
树状页表的根节点的物理地址保存在 satp 的 csr 中。
satp（Supervisor Address Translation and Protection）的 S 模式控制状态寄存器(CSR)控制了分页系统。


1. MODE 域可以开启分页并选择分页模式，我们此处选择 Sv39 模式(1000)。
2. ASID 域是地址空间 ID，用于多进程的地址空间隔离，我们此处不使用多进程，因此 ASID 域为 0 即可，还可以用来降低上下文切换的开销。
3. PPN 域是页表基址，它指向了最高级地址的物理页号。

`tag:，PPN 字段保存了根页表的物理地址，它以 4 KiB 的页面大小为单位。通常 M 模式的程序在第一次进入 S模式之前会把零写入 satp 以禁用分页，然后 S 模式的程序在初始化页表以后再次进行satp 寄存器的写操作。`
   
### TLB  (Translation Lookaside Buffer)
注意点：若PPN字段被修改，说明切换了映射方式，需要刷新TLB：`sfence.vma`指令，同样手动修改页表项后，也需要刷新TLB。

## 实验内容

# 物理内存管理
1. 探测可用的物理内存资源
2. 建立分页机制（划分页，建立页表）
3. 启动分页机制，让 CPU 的 MMU 把预先建立好的页表中的页表项读入到 TLB中
4. 根据页表项描述的虚拟页（Page）与物理页帧（Page Frame）的对应关系完成CPU对内存的读、写和执行操作

# 如何建立虚拟地址和物理地址之间的联系
1. 分配页表所在内存空间并初始化页表；
2. 设置好页基址寄存器（指向页表起始地址）//计算物理页号覆盖到 satp 寄存器
3. 刷新 TLB。

# first fit 分析
## 物理内存分配的过程：
1. 内存初始化：调用 `default_init` 函数初始化空闲内存块链表和空闲块的数量。
2. 初始化内存映射：调用 `default_init_memmap` 函数将一块新的空闲内存块加入内存映射中，将块首地址加入修改空闲内存块链表，增加空闲块数量。
3. 分配内存：调用 `default_alloc_pages` 函数来查找合适大小的空闲内存块，具体为查找到内存大于等于所需的块之后，若内存刚好相等则直接空闲内存块链表中取出，若内存大于则切成两个小块，把所需之外的另一小块重新加入链表当中，并且更新空闲块数量。
4. 释放内存：调用 `default_free_pages` 函数来释放指定的内存块，并检查前后是否有相邻的空闲内存块，存在则进行合并，之后重新加入空闲内存块链表当中，更新空闲块数量。

5. 为什么使用do while(0)
    >1.将代码包裹在do { ... } while (0) 中可以确保它们被视为一个整体,从而避免控制流被意外打断
    >2.使用 do { ... } while (0) 可以让宏支持单语句使用，如果不使用，在只有一条语句的情况下,宏定义可能会被误认为是一条独立的语句,从而导致语法错误或逻辑错误。
6. 改进：对于struct Page
    ```c
    struct Page {
     int ref;                        // page frame's reference counter
     uint64_t flags;                 // array of flags that describe the status of the page frame
     unsigned int property;          // the num of free block, used in first fit pm manager
     list_entry_t page_link;         // free list link
     };
    ```
    1. 由于结构体在内存空间是连续分布的，因此使用减去偏移量的方式来通过page link获取Page。但是若声明page_link为结构体的第一个成员变量，page_link的的地址就是Page这个结构体的地址，无需额外操作。
    2. 第一个满足的就分配，会有碎片化问题。

## best fit 实现
在分配函数中，遍历free list，找到满足要求的最小页即可。

`改进空间`
分配的时间复杂度为O(n)，可以考虑使用更优化的数据结构,如最优二叉树(Treap)或红黑树,来存储空闲块。这样可以大大提高查找最佳匹配块的效率,从而提升内存分配的性能。

## buddy system 
详情见具体代码
## slub 算法
详情见具体代码
## 硬件的可用物理内存范围的获取方法（思考题）
`如果 OS 无法提前知道当前硬件的可用物理内存范围，请问你有何办法让 OS 获取可用物理内存范围？`
<ol>
<li>RISC-V SBI 接口：RISC-V 架构定义了一套标准的监管模式接口(Supervisor Binary Interface, SBI)。OS 可以通过调用 SBI 的 sbi_query_memory() 函数来查询可用的物理内存区域。这个接口会返回内存区域的起始地址和大小。

</li>
<li>使用设备树(Device Tree)来描述硬件配置信息。
OS 可以解析设备树,从中获取可用物理内存区域的信息。bootloader 将DTB（device tree blob）加载到内存某个特定位置，或将位置传递给内核，内核通过解析DTB来获取硬件信息。
这种方法在嵌入式 RISC-V 系统中很常见。</li>
<li>向内存中写入数据并读取数据来检测，如果超过了内存的范围，无论写什么都会返回0</li>
</ol>

